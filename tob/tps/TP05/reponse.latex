% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
  12pt,
  french,
  notitlepage,
  onecolumn,
  openany]{article}
\usepackage{amsmath,amssymb}
\usepackage{lmodern}
\usepackage{ifxetex,ifluatex}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  pdftitle={TP 05 Tob},
  pdfauthor={Julien Blanchon},
  pdflang={fr-FR},
  pdfkeywords={tob, java},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage[a4paper,bindingoffset=0mm,inner=30mm,outer=30mm,top=30mm,bottom=30mm]{geometry}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{listings}
\lstset{language=Java}
\usepackage{tcolorbox}
\usepackage{fullpage}
\usepackage{color}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\lstset{ frame=tb, language=Java, aboveskip=3mm, belowskip=3mm, showstringspaces=false, columns=flexible, basicstyle={\small\ttfamily}, numbers=none, numberstyle=\tiny\color{gray}, keywordstyle=\color{blue}, commentstyle=\color{dkgreen}, stringstyle=\color{mauve}, breaklines=true, breakatwhitespace=true, tabsize=4 }
\lstset{ inputencoding = utf8, extendedchars = true, }
\textbackslash lstset\{literate=\% \{á\}\{\{'a\}\}1 \{é\}\{\{'e\}\}1
\{í\}\{\{'i\}\}1 \{ó\}\{\{'o\}\}1 \{ú\}\{\{'u\}\}1 \{Á\}\{\{'A\}\}1
\{É\}\{\{'E\}\}1 \{Í\}\{\{'I\}\}1 \{Ó\}\{\{'O\}\}1 \{Ú\}\{\{'U\}\}1
\{à\}\{\{`a\}\}1 \{è\}\{\{`e\}\}1 \{ì\}\{\{`i\}\}1 \{ò\}\{\{`o\}\}1
\{ù\}\{\{`u\}\}1 \{À\}\{\{`A\}\}1 \{È\}\{\{'E\}\}1 \{Ì\}\{\{`I\}\}1
\{Ò\}\{\{`O\}\}1 \{Ù\}\{\{`U\}\}1 \{ä\}\{\{"a\}\}1 \{ë\}\{\{"e\}\}1
\{ï\}\{\{"i\}\}1 \{ö\}\{\{"o\}\}1 \{ü\}\{\{"u\}\}1 \{Ä\}\{\{"A\}\}1
\{Ë\}\{\{"E\}\}1 \{Ï\}\{\{"I\}\}1 \{Ö\}\{\{"O\}\}1 \{Ü\}\{\{"U\}\}1
\{â\}\{\{\^{}a\}\}1 \{ê\}\{\{\^{}e\}\}1 \{î\}\{\{\^{}i\}\}1
\{ô\}\{\{\^{}o\}\}1 \{û\}\{\{\^{}u\}\}1 \{Â\}\{\{\^{}A\}\}1
\{Ê\}\{\{\^{}E\}\}1 \{Î\}\{\{\^{}I\}\}1 \{Ô\}\{\{\^{}O\}\}1
\{Û\}\{\{\^{}U\}\}1 \{œ\}\{\{\oe\}\}1 \{Œ\}\{\{\OE\}\}1
\{æ\}\{\{\ae\}\}1 \{Æ\}\{\{\AE\}\}1 \{ß\}\{\{\ss\}\}1 \{ç\}\{\{\c c\}\}1
\{Ç\}\{\{\c C\}\}1 \{ø\}\{\{\o\}\}1 \{å\}\{\{\r a\}\}1
\{Å\}\{\{\r A\}\}1 \{€\}\{\{\EUR\}\}1 \{£\}\{\{\pounds\}\}1 \}
\ifxetex
  % Load polyglossia as late as possible: uses bidi with RTL langages (e.g. Hebrew, Arabic)
  \usepackage{polyglossia}
  \setmainlanguage[]{french}
\else
  \usepackage[main=french]{babel}
% get rid of language-specific shorthands (see #6817):
\let\LanguageShortHands\languageshorthands
\def\languageshorthands#1{}
\fi
\ifluatex
  \usepackage{selnolig}  % disable illegal ligatures
\fi

\title{TP 05 Tob}
\usepackage{etoolbox}
\makeatletter
\providecommand{\subtitle}[1]{% add subtitle to \maketitle
  \apptocmd{\@title}{\par {\large #1 \par}}{}{}
}
\makeatother
\subtitle{Héritage comme spécialisation}
\author{Julien Blanchon}
\date{08-02-2020}

\begin{document}
\maketitle

\renewcommand*\contentsname{Table des matières}
{
\setcounter{tocdepth}{3}
\tableofcontents
}
\clearpage

\hypertarget{exercice-1-comprendre-la-classe-pointnommuxe9}{%
\section{Exercice 1 : Comprendre la classe
PointNommé}\label{exercice-1-comprendre-la-classe-pointnommuxe9}}

\emph{À partir du texte source de la classe PointNommé, expliquer les
différents éléments de cette classe et dessiner le diagramme de classes
UML avec cette classe PointNommé.}

Cette classe est constituée de 3 attributs: \texttt{vx}, \texttt{vy} et
\texttt{sonNom}.

\hypertarget{nom}{%
\subsection{Nom :}\label{nom}}

(Class) \textbf{PointNomme}

\hypertarget{attribut}{%
\subsection{Attribut:}\label{attribut}}

\begin{itemize}
\tightlist
\item
  \emph{double} vx
\item
  \emph{double} vy
\item
  \emph{String} sonNom
\end{itemize}

\hypertarget{muxe9thode}{%
\subsection{Méthode:}\label{muxe9thode}}

\begin{itemize}
\tightlist
\item
  \textbf{commande}:

  \begin{itemize}
  \tightlist
  \item
    \emph{void} setNom(\emph{String} sonNom)
  \item
    \emph{void} afficher()
  \item
    \emph{void} dessiner(\emph{Afficheur} afficheur)
  \end{itemize}
\item
  \textbf{requête}:

  \begin{itemize}
  \tightlist
  \item
    \emph{String} getNom()
  \end{itemize}
\end{itemize}

\hypertarget{constructeur}{%
\subsection{Constructeur:}\label{constructeur}}

\begin{itemize}
\tightlist
\item
  \emph{void} PointNomme(\emph{double} vx, vy, \emph{String} sonNom)
\end{itemize}

\hypertarget{exercice-2-comprendre-la-relation-dhuxe9ritage-entre-point-et-pointnomme}{%
\section{Exercice 2 : Comprendre la relation d'héritage entre Point et
PointNomme}\label{exercice-2-comprendre-la-relation-dhuxe9ritage-entre-point-et-pointnomme}}

\lstinputlisting{Point.java}

{[}frame=single{]}

\lstinputlisting{PointNomme.java}

{[}frame=single{]}

\hypertarget{exercice-3-segments-et-points-nommuxe9s}{%
\section{Exercice 3 : Segments et points
nommés}\label{exercice-3-segments-et-points-nommuxe9s}}

\hypertarget{peut-on-cruxe9er-un-segment-uxe0-partir-dun-point-et-dun-point-nommuxe9-comment-serait-affichuxe9-un-tel-segment-justifier-les-ruxe9ponses.}{%
\subsection{Peut-on créer un segment à partir d'un point et d'un point
nommé ? Comment serait affiché un tel segment ? Justifier les
réponses.}\label{peut-on-cruxe9er-un-segment-uxe0-partir-dun-point-et-dun-point-nommuxe9-comment-serait-affichuxe9-un-tel-segment-justifier-les-ruxe9ponses.}}

Oui (d'aprés le principe de substitution), ainsi il s'afficherais avec
PointNomme.afficher() et donc \texttt{sonNom\ :\ (x,\ y)}.

Il est au coeur du robot d'indexation de Google \texttt{GoogleBot}qui
applique ce principe aux graphes des \texttt{hyperliens} des pages
\texttt{html}. Mathématiquement les réputations des noeuds d'un graph
orienté appelé pagerank ou vecteur de poids (\(\pi\)) peut être
approchée (en point fixe) par un algorithme de puissance itérée
(\emph{voir Équation \ref{eqn:puissance_iteree}} calcul de rayon
spectral, plus grande valeur propre \(\lambda_{max}\)) dont l'itération
courante est :

\begin{equation}
\label{eqn:puissance_iteree}
\pi_{k+1} = \pi_{k}G
\end{equation}

Avec G une matrice dérivée de la matrice adjacente du graph orientée,
dont on à normalisé les valeurs et ajouté un coefficient (dumping
facteur) (pour ajouter de l'inertie peut être ?). Pour espérer une
convergence de l'algorithme il est bien évidemment nécessaire de prendre
\(\pi\) non nul !

\hypertarget{choix-ruxe9alisuxe9s}{%
\section{Choix réalisés}\label{choix-ruxe9alisuxe9s}}

\begin{itemize}
\tightlist
\item
  Gérer la gestion des arguments avec les exceptions, pour éviter les
  redondances de code.
\item
  Effectuer l'ensemble des opérations à l'aide de procédures plutôt que
  de fonction pour éviter de devoir produire des copies des données.
  Ainsi on utilise une seule est unique matrice \(G\) qui se voit être
  mise à jour au cours de l'exécution (\(A\) puis \(S\) puis \(G\) ou
  simplement \(A\)).
\item
  Utilisation de pointeur pour \texttt{Matrice\_Pleine} pour stocker les
  donner dans la \texttt{heap} et ainsi pouvoir traiter des réseaux plus
  grands sans avoir à changer \texttt{ulimit} (usage de
  \emph{\texttt{Storage\ Pool}} d'Ada).
\item
  On effectue tous les calculs, ainsi que les interactions avec les
  fichiers dans les modules matrices pour optimiser au mieux les
  calculs.
\item
  Stockage de certaines constantes pour ne pas avoir à les
  re--calculer/re-convertir (\texttt{Zero\_D}, \texttt{Un\_D},
  \texttt{Taille\_D}\ldots).
\item
  Les multiplications matrice-vecteur sont adaptés à la structure du
  problème. Pour des contraintes de calcul il vaut mieux parcourir les
  matrices par lignes donc la formule du produit est adaptée de la
  sorte.
\item
  En \texttt{Matrice\_Creuse}on ne stocke pas vraiment la matrice G mais
  seulement une représentation de celle-ci. C'est-à-dire la matrice
  Adjacente \(A\) (\texttt{A}) ainsi que le tableau \texttt{TabCount}
  avec le nombre d'éléments non nuls de A sur chaque ligne. Ainsi il
  rapide de déterminer :

  \begin{itemize}
  \tightlist
  \item
    Les lignes nulles (ainsi que la valeur des coefficients associés qui
    est \(\frac{1}{Taille} + cst\) stocké sous forme de constante du
    module).
  \item
    Les coefficients nul (qui sont ceux absents de \(A\)) dont la valeur
    vaut une constante \(cst\).
  \item
    Les coefficients non nuls dont la valeur vaut
    \(\frac{1}{Count} + cst\) avec \(\frac{1}{Count}\) stocké
    directement dans \texttt{TabCount}.
  \end{itemize}
\item
  On effectue un Rrie Rapide (\texttt{QuickSort}) qui à l'inconvéniant
  d'être récursif mais cependant la profondeur d'appel effective est
  trop faible pour induire un débordement de la pile.
\item
  De manière générale sauf pour le Trie Rapide on n'utilise pas de
  fonction récursive. On préfére les fonctions intératives qui évite
  tout débordement de pile.
\item
  Les programmes de tests ont été implémenter puis abandonner faute de
  ne plus être adapté à l'interface des modules (et fautes de temps pour
  les réadapter).
\end{itemize}

\hypertarget{raffinages}{%
\section{Raffinages:}\label{raffinages}}

\hypertarget{consigne}{%
\subsection{Consigne :}\label{consigne}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  L'exécutable \texttt{./pagerank} doit comporter 4 argument dont 3
  optionnels:
\end{enumerate}

\begin{itemize}
\tightlist
\item
  \texttt{fichier.net} est le chemin vers le fichier décrivant le
  réseau.
\item
  \texttt{-P} optionnel: Permet d'utiliser le l'implantation
  \texttt{Google\_Naive}. Par défaut (sans \texttt{-P}), on lance
  l'implantation \texttt{Google\_Creuse}.
\item
  \texttt{-I\ \textless{}int\textgreater{}} optionnel: Permet de
  spécifier le nombre maximal d'itérations. Par défaut 150.
\item
  \texttt{-A\ \textless{}float\textgreater{}} optionnel: Permet de
  spécifier le valeur d'\texttt{\textbackslash{}alpha}. Par défaut 0.85.
\item
  On adopte un programmation défensive pour l'appel de
  \texttt{./pagerank}.
\item
  \texttt{./pagerank\ -P\ -I\ 150\ -A\ 0.90\ exemple\_sujet.net}
\end{itemize}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Les résultat du programme seront écris dans des fichier d'extensions
  \texttt{.p} (pour le fichier pagerank) et \texttt{.ord} (pour le
  fichier poid) avec le même préfixe que le fichier \texttt{.net}.
\end{enumerate}

\begin{itemize}
\tightlist
\item
  \texttt{*.p} Liste le poids des nœuds par ordre décroissant.
\item
  \texttt{*.ord} Liste l'identifiant des nœuds par poids décroissant
  (PageRank croissant).
\end{itemize}

\hypertarget{raffinage-0-programme-principale}{%
\subsection{Raffinage 0 : Programme
Principale}\label{raffinage-0-programme-principale}}

\SetAlgorithmName{Raffinage}{raffinage}{list of Raffinage}
\setcounter{algocf}{-1}
\begin{algorithm}[H]
\Input{stdin("-P -I 150 -A 0.90 exemple\_sujet.net")}
\Output{\underline{exemple\_sujet.p}:Fichier \underline{exemple\_sujet.ord}:Fichier}
\BlankLine
Vérifier l'intégrité des arguments et les chargés en mémoire\;
\eIf{Integre}{
Calculer la matrice de Google $G$\;
Calculer le vecteur de poids $\pi$\;
Trier $\pi$ et déterminer le PageRank $Pk$\;
écrire les sorties\;
}{
Afficher la documentation\;
}
\caption{Programme Principale}
\end{algorithm}

\hypertarget{raffinage-1-vuxe9rifier-lintuxe9grituxe9-des-arguments-et-les-charguxe9s-en-muxe9moire}{%
\subsection{Raffinage 1 : Vérifier l'intégrité des arguments et les
chargés en
mémoire}\label{raffinage-1-vuxe9rifier-lintuxe9grituxe9-des-arguments-et-les-charguxe9s-en-muxe9moire}}

\SetAlgorithmName{Raffinage}{raffinage}{list of Raffinage}
\setcounter{algocf}{0}
\begin{algorithm}[H]
\Input{stdin("-P -I 150 -A 0.90 exemple\_sujet.net")}
\Output{type\_matrice:Integer max\_iter:Integer $\alpha$:Float integre:Boolean}
\BlankLine
Initialiser les paramètres avec les valeurs par défauts\;
\Begin{
Mettre à jour les paramètres \;
\Exception{}{
Max\_Iter\_Arg\_Exception
\progll{}{
integre := False\;
Afficher("-I max\_iter")
}
Alpha\_Arg\_Exception
\progll{}{
integre := False\;
Afficher("-A alpha")
}
Net\_Arg\_Exception
\progll{}{
integre := False\;
Afficher("chemin/fichier.net")
}
}
}
\caption{Vérifier l'intégrité des arguments et les chargés en mémoire}
\end{algorithm}

\hypertarget{raffinage-2-initialiser-les-paramuxe8tres-avec-les-valeurs-par-duxe9fauts}{%
\subsection{Raffinage 2 : Initialiser les paramètres avec les valeurs
par
défauts}\label{raffinage-2-initialiser-les-paramuxe8tres-avec-les-valeurs-par-duxe9fauts}}

\SetAlgorithmName{Raffinage}{raffinage}{list of Raffinage}
\setcounter{algocf}{1}
\begin{algorithm}[H]
\Input{}
\Output{type\_matrice max\_iter $\alpha$ Integre}
\BlankLine
type\_matrice := 0  \;
max\_iter := 150 \;
$\alpha$ := 0.85 \;
integre := True\;
\caption{Initialiser les paramètres avec les valeurs par défauts}
\end{algorithm}

\hypertarget{raffinage-2-mettre-uxe0-jour-les-paramuxe8tres}{%
\subsection{Raffinage 2 : Mettre à jour les
paramètres}\label{raffinage-2-mettre-uxe0-jour-les-paramuxe8tres}}

\SetAlgorithmName{Raffinage}{raffinage}{list of Raffinage}
\setcounter{algocf}{0}
\begin{algorithm}[H]
\Input{Argument:String Argument\_Count:Integer}
\Output{type\_matrice:Integer max\_iter:Integer $\alpha$:Float integre:Boolean $A$}
\BlankLine
\If{not(1$\leq$Argument\_Count$\geq$6)}{
Raise Argument\_Exception \;
}
I := 1\;
\While{I $\neq$ Argument\_Count}{
\uIf{Argument(I) := "-P"}{
type\_matrice := 1\;
}
\uElseIf{Argument(I) = "-I"}{
max\_iter := Argument(I+1)\;
I := I+1\;
}
\uElseIf{Argument(I) = "-A"}{
$\alpha$ := Argument(I+1) \;
I := I+1\;
}
\Else{
Ouvrir le fichier\;
Construire la matrice adjacente $A$
}
I:=I+1\;
}
\caption{Mettre à jour les paramètres}
\end{algorithm}

\hypertarget{principaux-algorithme}{%
\section{Principaux Algorithme:}\label{principaux-algorithme}}

\hypertarget{calcul-et-stockage-de-la-matrice-g-matrice_pleine}{%
\subsection{\texorpdfstring{Calcul et stockage de la matrice \(G\)
(\texttt{Matrice\_Pleine}):}{Calcul et stockage de la matrice G (Matrice\_Pleine):}}\label{calcul-et-stockage-de-la-matrice-g-matrice_pleine}}

\begin{lstlisting}[frame=single]
-- Procedure qui créer la matrice A(G) (Adjacente) et TabCount
-- à partir du fichier Fichier_Reseau.
procedure CalculA(Fichier_Reseau: in Ada.Text_IO.File_Type; G: in out T_Matrice_Pleine;
TabCount: in out T_Vecteur_Plein) is
X, Y: Integer;
begin
Initialiser(G);
Initialiser(TabCount);
while not( end_of_File(Fichier_Reseau) ) loop
Get(Fichier_Reseau, Y);
Get(Fichier_Reseau, X);
G(X, Y) := Un_D; -- Un_D = T_Double(1.0)
TabCount(Y) := TabCount(Y) + Un_D;
end loop;
end CalculA;

    -- Procedure qui créer la matrice S à partir de A(G) et TabCount.
    procedure CalculS(G: in out T_Matrice_Pleine; TabCount: in T_Vecteur_Plein) is
        UnDivTaille : constant T_Double := Un_D/Taille_D;
        UnDivCount : T_Double;
    begin
        for Y in 0..Taille-1 loop
            if TabCount(Y) = Zero_D then
                -- Ligne vide (Zero): 1/Taille sur tt les elts
                for X in 0..Taille-1 loop
                    G(X, Y) := UnDivTaille;
                end loop;
            else
                -- Ligne non vide: 1/Count sur les elts non nul
                UnDivCount := Un_D/TabCount(Y);
                for X in 0..Taille-1 loop
                    if G(X, Y) = Un_D then
                        G(X, Y) := UnDivCount;
                    end if;
                end loop;
            end if;
        end loop;
    end CalculS;

    -- Procedure qui creer la matrice G.
    procedure CalculG(alpha: in T_Double; G: in out T_Matrice_Pleine) is
      Val : constant T_Double := (Un_D-alpha)/Taille_D;
begin
for Y in 0..Taille-1 loop
for X in 0..Taille-1 loop
G(X, Y) := alpha*G(X, Y) + Val;
end loop;
end loop;
end CalculG;
\end{lstlisting}

\hypertarget{calcul-et-stockage-de-la-matrice-g-matrice_creuse}{%
\subsection{\texorpdfstring{Calcul et stockage de la matrice \(G\)
(\texttt{Matrice\_Creuse}):}{Calcul et stockage de la matrice G (Matrice\_Creuse):}}\label{calcul-et-stockage-de-la-matrice-g-matrice_creuse}}

\begin{lstlisting}[frame=single]
-- Procedure qui créer la matrice A(G) (Adjacente) et TabCount
-- à partir du fichier Fichier_Reseau.
procedure CalculA(Fichier_Reseau: in Ada.Text_IO.File_Type; G: in out T_Matrice_Creuse;
TabCount: in out T_Vecteur_Plein) is
X, Y : Integer;
Vcopy : T_Vecteur_Creux;
begin
Initialiser(G);
Initialiser(TabCount);
while not end_of_File(Fichier_Reseau) loop
Get(Fichier_Reseau, Y);
Get(Fichier_Reseau, X);
if G(Y) = Null then
G(Y) := New T_Cellule'(X, Un_D, Null);
Vcopy := G(Y);
else
Vcopy.All.Suivant := New T_Cellule'(X, Un_D, Null);
Vcopy := Vcopy.All.Suivant;
end if;
TabCount(Y) := TabCount(Y) + Un_D;
end loop;
Free(Vcopy);

end CalculA;

-- Procedure qui pre-calcul les alpha*(1/Count)+(1-alpha)/Taille
procedure MiseAJourTabCount(TabCount: in out T_Vecteur_Plein; alpha: in T_Double) is
Val : constant T_Double := (Un_D-alpha)/Taille_D;
begin
for Y in 0..Taille-1 loop
if TabCount(Y) /= Zero_D then
TabCount(Y) := (alpha/TabCount(Y)) + Val;
end if;
end loop;
end MiseAJourTabCount;
\end{lstlisting}

\hypertarget{ituxe9ration-puissance-ituxe9ruxe9e-matrice_pleine}{%
\subsection{\texorpdfstring{Itération Puissance Itérée
(\texttt{Matrice\_Pleine}):}{Itération Puissance Itérée (Matrice\_Pleine):}}\label{ituxe9ration-puissance-ituxe9ruxe9e-matrice_pleine}}

\begin{lstlisting}[frame=single]
-- Fonction qui effectue une itération.
function Iteration(G: in T_Matrice_Pleine; Pi: in T_Vecteur_Plein) return T_Vecteur_Plein is
Pinew : T_Vecteur_Plein;
begin
Initialiser(Pinew);
for Y in 0..Taille-1 loop
for X in 0..Taille-1 loop
Pinew(X) := Pinew(X) + Pi(Y)*G(X, Y);
end loop;
end loop;
return Pinew;
end Iteration;
\end{lstlisting}

\hypertarget{ituxe9ration-puissance-ituxe9ruxe9e-matrice_creuse}{%
\subsection{\texorpdfstring{Itération Puissance Itérée
(\texttt{Matrice\_Creuse}):}{Itération Puissance Itérée (Matrice\_Creuse):}}\label{ituxe9ration-puissance-ituxe9ruxe9e-matrice_creuse}}

\begin{lstlisting}[frame=single]
-- Fonction qui effectue une itération.
function Iteration(G: in T_Matrice_Creuse; Pi: in T_Vecteur_Plein; alpha: in T_Double; TabCount: in T_Vecteur_Plein) return T_Vecteur_Plein is
Pinew : T_Vecteur_Plein;
Curseur : T_Vecteur_Creux;
Val : constant T_Double := (Un_D-alpha)/Taille_D;
ValVide : constant T_Double := alpha/Taille_D + Val;
TabCountVal : T_Double;
begin
Initialiser(Pinew);
for Y in 0..Taille-1 loop
Curseur := G(Y);
TabCountVal := TabCount(Y);
if TabCountVal = Zero_D then
for X in 0..Taille-1 loop
Pinew(X) := Pinew(X) + Pi(Y)*ValVide;
end loop;
else
for X in 0..Taille-1 loop
if Curseur /= Null and then Curseur.All.Indice = X then
Pinew(X) := Pinew(X) + Pi(Y)*TabCountVal;
Curseur := Curseur.All.Suivant;
else
Pinew(X) := Pinew(X) + Pi(Y)*Val;
end if;
end loop;
end if;
Curseur := Null;
Free(Curseur);
end loop;
return Pinew;
end Iteration;
\end{lstlisting}

\hypertarget{trie-rapide-quicksort-du-vecteur-poids}{%
\subsection{\texorpdfstring{Trie Rapide (\texttt{QuickSort}) du vecteur
poids:}{Trie Rapide (QuickSort) du vecteur poids:}}\label{trie-rapide-quicksort-du-vecteur-poids}}

\begin{lstlisting}[frame=single]
-- Procedure qui trie Pi et qui garde dans Index des permutations du trie
procedure TrierPi(Pi: in out T_Vecteur_Plein; Index: in out T_Vecteur_PleinInteger) is
begin
for K in 0..Taille-1 loop
Index(K) := K;
end loop;
Tri_Rapide(Pi, Index, 0, Taille-1);
end TrierPi;

-- Tri relatif des elts du tableau T entre premier et dernier avec le pivot.
procedure Partitionner(T: in out T_Vecteur_Plein; Index: in out T_Vecteur_PleinInteger;
premier: in Integer; dernier: in Integer; pivot: in out Integer) is
J: Integer;
begin
Echanger(T, pivot, dernier);
Echanger(Index, pivot, dernier);
J := premier;
for I in premier..dernier-1 loop
if T(I) >= T(dernier) then -- >= pour un trie décroissant.
Echanger(T, I, J);
Echanger(Index, I, J);
J := J + 1;
end if;
end loop;
Echanger(T, dernier, J);
Echanger(Index, dernier, J);
pivot := J;
end Partitionner;

-- Tri globale du tableau T entre premier en dernier
procedure Tri_Rapide(T: in out T_Vecteur_Plein; Index: in out T_Vecteur_PleinInteger;
premier: Integer; dernier: Integer) is
pivot : Integer;
begin
if premier < dernier then
pivot := premier;
Partitionner(T, Index, premier, dernier, pivot);
Tri_Rapide(T, Index, premier, pivot-1);
Tri_Rapide(T, Index, pivot+1, dernier);
end if;
end Tri_Rapide;
\end{lstlisting}

\hypertarget{difficultuxe9-rencontruxe9-solution-et-conclusion}{%
\section{Difficulté rencontré, solution et
conclusion}\label{difficultuxe9-rencontruxe9-solution-et-conclusion}}

La principale difficulté a été d'optimiser le programme que ce soit en
temps ainsi qu'en mémoire. Pour cela on a préféré le plus souvent
calculer plutôt que stocker car certains réseaux (en particulier
\texttt{Linux}) sont très gros et pas forcément très dense. Et ils
dépasseraient la mémoire accesible. La solution a donc été de stocker
une représentation de la matrice \(G\) à savoir la matrice adjacente
\texttt{A} ainsi que le tableau \texttt{TabCount}. Il reste encore
beaucoup de travail dans l'optimisation de l'algorithme et de son
implémentation.

Ensuite il a aussi été très difficule de bien structurer les différentes
procédure et fonction dans des modules (/packetage) cohérents. Faute de
temps ce travail n'est pas correctement abouti.

En conclusion il reste encore beaucoup de choses à faire malheureusement
je n'ai pas assez de temps pour terminé comme j'aimerais ce projet. Il
semblerait que l'algorithme de puissance itérée ne soit vraiment pas
bien adaptée aux trop gros réseaux (tel que \texttt{Linux}) il faudrait
réfléchir à une autre méthode pour approcher le vecteur poids.

\end{document}
